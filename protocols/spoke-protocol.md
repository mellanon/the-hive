# Spoke Protocol

> **Status:** Draft
> **Source:** [pai-collab Issue #80](https://github.com/mellanon/pai-collab/issues/80)

## Purpose

The spoke protocol defines how an operator projects their local state to a hub without coupling local internals to the network. It's the contract between an operator's private workspace and the shared coordination surface.

## Design Principles

1. **Projection, not exposure** — The spoke publishes a curated view. The hub never reaches into local state.
2. **Two files** — manifest (human-maintained identity) + status (auto-generated snapshot). Minimal surface area.
3. **Signed by default** — All spoke updates are commit-signed with the operator's Ed25519 SSH key. The spoke is self-authenticating.
4. **Generic** — The protocol works with any hub, not just pai-collab. A spoke can project to multiple hives.
5. **Lightweight** — YAML files in `.collab/` at the repo root. No infrastructure required.

## Contract

### manifest.yaml (human-maintained)

The stable identity of the spoke. Changes rarely.

```yaml
schemaVersion: "1.0"
name: <project-name>
hub: <org/repo>
project: <project-id>
maintainer: <github-handle>
license: MIT | Apache-2.0 | BSD-2-Clause | BSD-3-Clause | CC-BY-4.0
identity:
  handle: <canonical-handle>
  publicKey: "ssh-ed25519 AAAA..."       # Ed25519 SSH public key
  fingerprint: "SHA256:+sgg04W..."       # key fingerprint
security:
  reflexes:
    signing: true                        # Reflex A: commit signing enabled
    secretScanning: true                 # Reflex A: gitleaks pre-commit hook installed
    sandboxEnforcer: true                # Reflex C: acquisition sandbox active
    contentFilter: true                  # Reflex D: content filter hook active
status:
  test: <test command>
  healthCheck: <health check command>
```

> The `identity` section binds the spoke to a cryptographic key. When the hub receives a spoke update, it can verify the commit signature matches the declared public key. This prevents spoke spoofing — only the holder of the private key can produce valid spoke updates. See [Operator Identity](operator-identity.md) for the full identity model.

> The `security.reflexes` section declares which security reflexes the operator has active. Since the manifest is signed, false claims are attributable. The hub can validate signing (cryptographic proof via CI Gate 1) and treat other claims as self-attested trust signals. See [Trust Protocol — Observable Setup Signals](trust-protocol.md) for how these feed into trust scoring.

### status.yaml (auto-generated)

A point-in-time snapshot of spoke state. Generated by CLI or CI.

```yaml
schemaVersion: "1.0"
generatedAt: <ISO 8601>
generatedBy: <tool + version>

phase: <specify | build | harden | contrib-prep | review | shipped | evolving>
tests:
  passing: <int>
  failing: <int>
git:
  branch: <string>
  lastCommit: <ISO 8601 date>
  dirty: <boolean>
  behindRemote: <int>
```

## CLI Commands

`blackboard` is a single CLI that operates at all three blackboard levels via an explicit `--level` flag. The spoke-level commands are documented here; see the full CLI specification in [ARCHITECTURE.md](../ARCHITECTURE.md).

### Spoke-level commands

| Command | Description |
|---------|-------------|
| `blackboard init --level spoke` | Create `.collab/` with manifest template + GitHub Action |
| `blackboard status --level spoke` | Generate status.yaml from current repo state |
| `blackboard validate --level spoke` | Validate manifest + status against schema |

### Hub-level commands (spoke aggregation)

| Command | Description |
|---------|-------------|
| `blackboard pull --level hub` | Aggregate status from all registered spokes |
| `blackboard registry --level hub` | List registered spokes and their health |

## Security Considerations

### Commit Signing (Required)

All spoke updates (commits to `.collab/`) **must** be signed with the operator's Ed25519 SSH key. This provides:

- **Authorship verification** — the hub can verify spoke updates came from the declared operator
- **Tamper detection** — unsigned or incorrectly signed commits are rejected at the hub
- **Non-repudiation** — the operator cannot deny authorship of a signed spoke update

Hub CI should enforce signed commits on spoke-related PRs:
```bash
# Verify commit signature against hive's allowed-signers
git config gpg.ssh.allowedSignersFile .hive/allowed-signers
git log --show-signature --format='%H %G?' origin/main..HEAD | grep -v ' G$' && echo "UNSIGNED COMMITS FOUND" && exit 1
```

### Additional Considerations

From [Steffen's security review](https://github.com/mellanon/pai-collab/issues/80):

- **Command injection:** manifest.yaml `status.test` field must be whitelisted, not executed directly
- **Supply chain:** GitHub Actions must pin dependencies with integrity hashes
- **Metadata exposure:** `git.dirty` and `git.behindRemote` expose operational state — consider hashing instead of exposing raw values

## Open Questions

1. How does a spoke register with a hub? (Currently manual REGISTRY.md entry)
2. How frequently should status.yaml be regenerated? (CI on push? Scheduled?)
3. Should status.yaml include local blackboard summary data? (Agent count, work item count)
4. Multi-hub: can one spoke project to multiple hives simultaneously?
