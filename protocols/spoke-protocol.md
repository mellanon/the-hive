# Spoke Protocol

> **Status:** Review
> **Source:** [pai-collab Issue #80](https://github.com/mellanon/pai-collab/issues/80)
> **Reference Implementation:** [hive-spoke](https://github.com/mellanon/hive-spoke) (AGPL-3.0)
> **Operations Guide:** [sops/spoke-operations.md](https://github.com/mellanon/pai-collab/blob/main/sops/spoke-operations.md) in pai-collab

## Purpose

The spoke protocol defines how an operator projects their local state to a hub without coupling local internals to the network. It's the contract between an operator's private workspace and the shared coordination surface.

## Design Principles

1. **Projection, not exposure** — The spoke publishes a curated view via `.collab/`. The hub reads this projection surface from the spoke's public repo — it never reaches into local state beyond `.collab/`.
2. **Three files** — manifest (human-maintained identity) + status (auto-generated snapshot) + operator (tiered profile). Minimal surface area.
3. **Signed by default** — All spoke updates are commit-signed with the operator's Ed25519 SSH key. The spoke is self-authenticating.
4. **Generic** — The protocol works with any hub, not just pai-collab. A spoke can project to multiple hives.
5. **Lightweight** — YAML files in `.collab/` at the repo root. No infrastructure required.
6. **Pull, not push** — The hub fetches spoke state on demand from public repos. No PRs needed for status updates. Private spokes can push via PR as a fallback.

## Contract

### manifest.yaml (human-maintained)

The stable identity of the spoke. Changes rarely.

```yaml
schemaVersion: "1.0"
name: <project-name>
hub: <org/repo>
project: <project-id>
maintainer: <github-handle>
license: MIT | Apache-2.0 | BSD-2-Clause | BSD-3-Clause | CC-BY-4.0 | AGPL-3.0
identity:
  handle: <canonical-handle>
  publicKey: "ssh-ed25519 AAAA..."       # Ed25519 SSH public key
  fingerprint: "SHA256:+sgg04W..."       # key fingerprint
security:
  reflexes:
    signing: true                        # Reflex A: commit signing enabled
    secretScanning: true                 # Reflex A: gitleaks pre-commit hook installed
    sandboxEnforcer: true                # Reflex C: acquisition sandbox active
    contentFilter: true                  # Reflex D: content filter hook active
status:
  test: <test command>
  healthCheck: <health check command>
```

> The `identity` section binds the spoke to a cryptographic key. When the hub receives a spoke update, it can verify the commit signature matches the declared public key. This prevents spoke spoofing — only the holder of the private key can produce valid spoke updates. See [Operator Identity](operator-identity.md) for the full identity model.

> The `security.reflexes` section declares which security reflexes the operator has active. Since the manifest is signed, false claims are attributable. The hub can validate signing (cryptographic proof via CI Gate 1) and treat other claims as self-attested trust signals. See [Trust Protocol — Observable Setup Signals](trust-protocol.md) for how these feed into trust scoring.

### status.yaml (auto-generated)

A point-in-time snapshot of spoke state. Generated by CLI or CI.

```yaml
schemaVersion: "1.0"
generatedAt: <ISO 8601>
generatedBy: <tool + version>

phase: <specify | build | harden | contrib-prep | review | shipped | evolving>
tests:
  passing: <int>
  failing: <int>
git:
  branch: <string>
  lastCommit: <ISO 8601 date>
  dirty: <boolean>
  behindRemote: <int>
```

## CLI Commands

The reference implementation is [hive-spoke](https://github.com/mellanon/hive-spoke). The future unified `blackboard` CLI will wrap these commands with `--level spoke|hub` flags.

### Spoke-level commands (run from spoke repo)

| Command | Description |
|---------|-------------|
| `hive-spoke init --hub <org/repo>` | Create `.collab/` with manifest, status, operator templates |
| `hive-spoke status` | Generate status.yaml from current repo state (git + tests) |
| `hive-spoke validate` | Validate all `.collab/` files against schemas, check signing, cross-reference consistency |
| `hive-spoke publish` | Push `.collab/` to hub via PR (for private repos only) |

### Hub-level commands (run from hub repo)

| Command | Description |
|---------|-------------|
| `hive-spoke pull` | Fetch `.collab/` from each spoke's public repo via GitHub API, display aggregated dashboard |
| `hive-spoke verify` | Cross-reference spoke signing keys against `.hive/allowed-signers` trust anchor |

### Data Flow

```
PUBLIC SPOKES (default):
  Spoke: init → status → validate → commit → push (to spoke repo)
  Hub:   pull → fetches .collab/ from spoke repos via gh api → dashboard

PRIVATE SPOKES (fallback):
  Spoke: init → status → validate → publish → PR created on hub
  Hub:   maintainer merges PR → .collab/ persisted in hub repo
```

## Security Considerations

### Commit Signing (Required)

All spoke updates (commits to `.collab/`) **must** be signed with the operator's Ed25519 SSH key. This provides:

- **Authorship verification** — the hub can verify spoke updates came from the declared operator
- **Tamper detection** — unsigned or incorrectly signed commits are rejected at the hub
- **Non-repudiation** — the operator cannot deny authorship of a signed spoke update

Hub CI should enforce signed commits on spoke-related PRs:
```bash
# Verify commit signature against hive's allowed-signers
git config gpg.ssh.allowedSignersFile .hive/allowed-signers
git log --show-signature --format='%H %G?' origin/main..HEAD | grep -v ' G$' && echo "UNSIGNED COMMITS FOUND" && exit 1
```

### Additional Considerations

From [Steffen's security review](https://github.com/mellanon/pai-collab/issues/80):

- **Command injection:** manifest.yaml `status.test` field must be whitelisted, not executed directly
- **Supply chain:** GitHub Actions must pin dependencies with integrity hashes
- **Metadata exposure:** `git.dirty` and `git.behindRemote` expose operational state — consider hashing instead of exposing raw values

## Spoke Compliance Verification

Compliance is verified through four layers. For public spokes, the hub fetches `.collab/` and verifies on read. For private spokes that push via PR, compliance is verified at the projection boundary when the PR is submitted.

### The Four Verification Layers

```
LAYER 1: PROVABLE (cryptographic evidence)
  What the hub can mathematically verify.

LAYER 2: DETECTABLE (negative signals)
  Failures that reveal missing local setup.

LAYER 3: ATTESTED (signed claims)
  Operator declarations in a signed manifest.

LAYER 4: STRUCTURAL (schema conformance)
  Whether .collab/ files exist and are valid.
```

### Layer 1: Provable

Evidence that is cryptographically verifiable — the hub doesn't trust, it checks.

| Signal | Verification | CI Gate |
|--------|-------------|---------|
| Commits are signed | Signature checked against `allowed-signers` | Gate 1: Identity |
| Signing key matches manifest | `manifest.yaml` `identity.publicKey` matches the commit signer | Gate 1: Identity |

**Strength:** Mathematical certainty. A valid Ed25519 signature cannot be forged.

### Layer 2: Detectable

The absence of a problem is evidence the local reflex is working. When local reflexes fail, the hub catches the failure — proving the spoke's defenses have gaps.

| Signal | What It Reveals | CI Gate |
|--------|----------------|---------|
| Secret found in PR | Reflex A (pre-commit gitleaks) is not running locally | Gate 2: Security |
| Unsigned commit in PR | Commit signing is not configured | Gate 1: Identity |
| Malformed `.collab/` files | `hive-spoke validate` is not being run before projection | Gate 3: Schema |
| Stale `status.yaml` (`generatedAt` older than threshold) | Spoke is not maintaining its status | Gate 4: Governance |

**Strength:** Absence of evidence IS evidence of absence. If the hub catches what local reflexes should have blocked, the spoke is non-compliant.

### Layer 3: Attested

Claims in `manifest.yaml` about local setup that the hub cannot independently verify. Because the manifest is signed, false claims are attributable — the operator's Ed25519 signature binds them to the declaration.

| Claim | What It Means | Hub Action |
|-------|--------------|------------|
| `security.reflexes.signing: true` | Operator claims commit signing is active | Verified by Layer 1 (provable) — this one upgrades |
| `security.reflexes.secretScanning: true` | Operator claims gitleaks pre-commit hook is installed | Accepted as signed attestation. Falsified if Layer 2 detects secrets. |
| `security.reflexes.sandboxEnforcer: true` | Operator claims inbound content is quarantined | Accepted as signed attestation. Not independently verifiable by the hub. |
| `security.reflexes.contentFilter: true` | Operator claims content filter scans reads | Accepted as signed attestation. Not independently verifiable by the hub. |

**Strength:** Not proof — but lying is traceable. The signed manifest creates non-repudiation: the operator cannot deny they claimed a reflex was active.

> The verification asymmetry is intentional. Outbound reflexes (signing, secret scanning) produce evidence the hub can check. Inbound reflexes (sandbox, content filter) protect the operator's own environment — the hub accepts the claim because the risk is borne by the spoke, not the hub. See [ARCHITECTURE.md](../ARCHITECTURE.md) → Verification Asymmetry.

### Layer 4: Structural

Whether the spoke's `.collab/` directory exists and its files conform to the expected schemas.

| Check | Verification | When |
|-------|-------------|------|
| `.collab/manifest.yaml` exists and is valid | Zod schema validation | `hive-spoke validate` (local) + Hub CI Gate 3 |
| `.collab/status.yaml` exists and is valid | Zod schema validation | `hive-spoke validate` (local) + Hub CI Gate 3 |
| `.collab/operator.yaml` Tier 1 is present | Zod schema validation | `hive-spoke validate` (local) + Hub CI Gate 3 |
| Cross-references are consistent | manifest `hub` matches hive, `identity.publicKey` matches signing key | `hive-spoke validate` (local) |

**Strength:** Binary. Either the structure is right or it isn't.

### Local Pre-Flight: `hive-spoke validate --level spoke`

Before projecting to the hub, the operator runs validation locally. This catches setup errors before the hub CI ever sees them:

```bash
hive-spoke validate --level spoke
# ✓ .collab/manifest.yaml — valid schema, required fields present
# ✓ .collab/status.yaml — valid schema, generatedAt is recent
# ✓ .collab/operator.yaml — Tier 1 fields present, handle matches manifest
# ✓ Signing configured — gpg.format=ssh, signing key exists
# ✓ Cross-references — hub field matches known hive, publicKey matches git signing key
# ✗ status.yaml generatedAt is 3 days old — run: hive-spoke status
```

### Compliance Summary

```
Spoke compliance = Provable evidence (Layer 1: signatures verify)
                 + Absence of negative signals (Layer 2: no secrets, no unsigned commits)
                 + Signed attestation (Layer 3: manifest claims about local reflexes)
                 + Structural conformance (Layer 4: .collab/ files valid)
                 + Freshness (status.yaml generatedAt is recent)
```

The hub doesn't need to inspect the spoke. It verifies at the boundary, detects failures through negative signals, and accepts signed attestation for the rest.

## Resolved Questions

1. **How does a spoke register with a hub?** — The hub discovers spokes via `PROJECT.yaml` → `source.repo` fields. `hive-spoke init` scaffolds `.collab/` in the spoke repo. The hub's `pull` command fetches from all repos that have `.collab/`. No manual registration step needed beyond having a `PROJECT.yaml` with a `source.repo` field on the hub.
2. **How frequently should status.yaml be regenerated?** — Operator-driven, not automated. The operator runs `hive-spoke status` when they've made meaningful progress, commits, and pushes. The hub pulls on demand. CI validates the spoke's `.collab/` on push but does not auto-publish.

## Open Questions

1. Should status.yaml include local blackboard summary data? (Agent count, work item count)
2. Multi-hub: can one spoke project to multiple hives simultaneously?
3. How should the hub handle spoke repos that become inaccessible? (deleted, made private, renamed)
